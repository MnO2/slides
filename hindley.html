<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .red    { color: #FF4943; }
      .gray   { color: #787878; }
      .green  { color: #87A558; }
      .blue   { color: #41C8F0; }
      .yellow { color: #DBEC62; }
      .large p { font-size: 4em; }

      .large-picture img { width: 400px; }
      .medium-picture img { width: 250px; }
      .small-picture img { width: 200px; }
      .tiny-picture img { width: 100px; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Hindley Milner Type System and Higher-rank Extension


### Paul Meng
### Haskell.SG, July 1st, 2015.

---

## ![h-and-m](image/HM.png) T-shirt

.large-picture[![what-part](image/what_part_of_types_dont_you_understand.jpg)]
--

.small-picture[![wtf](image/jackie-chan-wtf.png)]


---


## Hindley Milner Type Rules

.large-picture[![syntax-directed-hm](image/syntax_directed_hm.jpg)]
.small-picture[![wtf](image/elvish.jpg)]

* It's quite daunting at first glance, and you just can't understand any single bit of it if you are not from academic background.

---

## Why is it so hard ?

* .red[The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.]
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.


---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* .red[Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.]
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.


---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* .red[Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)]
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.

---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* .red[You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?]
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.

---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - .red[Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell]
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.

---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* .red[It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?]
  - Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.

---

## Why is it so hard ?

* The language (predicate logic) used to describe the system is the language used in academy. The purpose is to be exact but not for comprehension.
* Academic people just use lots of jargon in communication for brevity. As a newcomer you have to pickup the intuition and jargon.
* Sometimes the form you see is not the form where you could read out an algorithm. (Not syntax-directed form)
* You don't understand why it has to be in a simplified formal language when it comes to a tutorial. What it has to do with Haskell? Can I just learn the model for the real world Haskell?
  - Haskell's type system is much more complicated. but as a ML family member, it is possible to extend the simplified formal language to the complexity of Haskell
* It's unclear why we need Hindley Milner type system? What's the motivation for the researcher developed such kind of system. We just accepted it as a part of the programming language?
  - .red[Type system was invented to build the foundation of mathematics in the early 20th Century, but later found very useful as the theory for PL, and it inspired lots of extensions and new models ever since. Although with its defect, it is good to learn that to get the idea of similar models in the family.]

---

## Using predicate logic as lightly as possible

* .red[This talk tries to derive it from intuition and examples.]

* Trade off exactnesss for easier comprehension.

* We would start from the simplified one then move to the harder ones.

---

## Using predicate logic as lightly as possible

* This talk tries to derive it from intuition and examples.

* .red[Trade off exactnesss for easier comprehension.]

* We would start from the simplified one then move to the harder ones.


---

## Using predicate logic as lightly as possible

* This talk tries to derive it from intuition and examples.

* Trade off exactnesss for easier comprehension.

* .red[We would start from the simplified one then move to the harder ones.]


---

## Starting off with an observation

* In McDonald, a simple burger is consist of breads and beef.

.tiny-picture[![](image/big-mac-bread.jpg)]
.tiny-picture[![](image/big-mac-beef.jpg)]

* How could we express that we would like to "make" a burger?

* First of all, We have to define a simplified formal language so that we have a language to say.

---

## Starting off with an observation

* Simplified formal language.

``` haskell
data Term = Var Name              -- x
          | Lit BurgerType        -- burger
          | App Term Term         -- f x
          | Lam Name Term         -- \x. x
```


--
* I would really love to call this language as .blue[System Mc], but that is actually a misnomer. Its name is .blue[lambda calculus].
* Then .blue["make"] could be expressed as

--

.medium-picture[![](image/burger_lambda.jpg)]

``` haskell
(\x. \y. burger) bread beef
```

--
* It's unsafe. You could put anything into the x, y and makes it a burger.

.tiny-picture[![](image/cockroach.jpg)]

---

## Simply typed lambda calculus

* Therefore we extend this language, to add type annotation: .blue[x :: Burger] 


``` haskell
data Term = Var Name              -- x
          | Lit BurgerType        -- burger
          | App Term Term         -- f x
          | Lam Name Term         -- \x. x
          | Ann Term Rho          -- (f x) :: Burger
```

* Label it!  .tiny-picture[![](image/burger-king.png)]

* Given a built-in rule (We, the programmer as the oracle, declare this as the .blue[Hamburger Making theorem].)

$$
make :: Bread \rightarrow Beef \rightarrow Burger
$$

* Then we could check if this program follows the rule of the theorem.

``` haskell
((\x. \y. burger) :: Bread -> Beef -> Burger) bread) beef
```


---

## It's not only for type checking.

* Because the rule is not ambiguous, we could run the rule checking .blue[backward] to learn the type of a term, with all the constant's type known.

* It's like guessing the labels with the values given.

.tiny-picture[![](image/big-mac-bread.jpg)]
.tiny-picture[![](image/big-mac-beef.jpg)]
=====>
.tiny-picture[![](image/burger-king.png)]

* With human brains, we could see the answer in a glance, but how to derive an algorithm?

* Rule:
$$
make :: Bread \rightarrow Beef \rightarrow Burger
$$

* Missing types of `x` and `y`

``` haskell
((\x: ??? . \y: ??? . burger) :: Bread -> Beef -> Burger) bread) beef
```

---

## Let's get started from fuzzy idea

* We would like to have a `inferRho` function, when given a value level `Term` expression, return an inferred `Rho` type. And since the inference involves some states, we have to put it in a Monad `Tc`.

``` haskell
inferRho :: Term -> Tc Rho
```

--

* We allocate a "type variable", and leave the `tcRho` to fill out the type variable and read it afterward. We also put it in another type to mark that we are doing "inference".

``` haskell
inferRho expr
  = do { ref <- newTcRef (error "inferRho: empty result")
       ; tcRho expr (Infer ref)
       ; readTcRef ref }
```
* Then what's next?

---

## Target: Reformulate our problem


* Notice that we could write down some equations when seeing the formula. Then we could solve the eqautions like high-school algebra.

``` haskell
((\x: ??? . \y: ??? . burger) :: Bread -> Beef -> Burger) bread) beef
```

``` haskell
a -> b -> c = Bread -> Beef -> Burger
c = Burger
```

* Is this observation correct? 

--

* .blue[Yes.] The essense of type inference is walking the abstract syntax tree and collect constraints we must satisfy. Therefore we would reformulate the problem to so-called .blue[unification problem].

.small-picture[![](image/doge_problem.jpg)]

---

## Target: Reformulate our problem

* Unification problem example

$$
T_1 \rightarrow T_1  = Int \rightarrow T_2
$$

--

* Then we have a solution 

$$ \\{ T_1 \Rightarrow Int , \, T_2 \Rightarrow Int \\} $$

--

* Our target is to walk the tree and collect Constraints

``` haskell
a -> b -> c = Bread -> Beef -> Burger
c = Burger
```

* Then solving the equations gives us `b = Beef` and `a = Bread`

--

* We call this substitution "unifier" in academic terminology.


---

## Formulation: Type variable expansion

* But notice that we don't have .blue[type variable] `a`, `b`, `c`, etc. either in the syntax or parsed abstract syntax tree.

``` haskell
((\x: ??? . \y: ??? . burger) :: Bread -> Beef -> Burger) bread) beef
```

--

* We have to figure out a way to generate the .blue[type variables]. In more complicated cases it also comes with arrow (->), and it makes up a .blue[type expression].

--

* Grammar for type variable expansion.

$$
\rho ::= \tau \\\
\tau ::= \tau \rightarrow \tau \, \vert \, ContantType \\\
$$

* Example
$$ \rho \Rightarrow \tau \rightarrow \tau \Rightarrow \tau \rightarrow \tau \rightarrow \tau \Rightarrow Int \rightarrow Int \rightarrow Int $$

* With this grammar, we have the .blue[meta type variable] for expanding type expressions,  And that is the `Rho` we mentioned in `inferRho`.


---
## Formulation: Type variable expansion

$$
\rho ::= \tau \\\
\tau ::= \tau \rightarrow \tau \, \vert \, ContantType \\\
$$

* And now we have the .blue[type expression] defined in Haskell.

``` haskell
type Rho   = Type
type Tau   = Type

data Type = Fun    Type Type     -- Function type
          | TyCon  TyCon         -- Type constants
          | TyVar  TyVar         -- Type variable with name
          | MetaTv MetaTv        -- A meta type variable

data TyVar = SkolemTv String Uniq
-- Like the "a1", "a2", "a3" you see in GHC compiler message

data MetaTv = Meta Uniq TyRef  -- Can unify with any tau-type

type TyRef = IORef (Maybe Tau)
        -- 'Nothing' means the type variable is not substituted
        -- 'Just ty' means it has been substituted by 'ty'

```

--
* Then we could start walking the AST of the expression

---

## Tree Walking

``` haskell
((\x: ??? . \y: ??? . burger) :: Bread -> Beef -> Burger) bread) beef
```

``` haskell
inferRho expr
  = do { ref <- newTcRef (error "inferRho: empty result")
       ; tcRho expr (Infer ref)
       ; readTcRef ref }
```

.medium-picture[![slc-ex5](image/SLC_ex1.svg)]

---

## Tree Walking

``` haskell
tcRho (App fun arg) exp_ty
  = do { fun_ty <- inferRho fun
-- supposing that we have inferred the definition of fun
       ; (arg_ty, res_ty) <- unifyFun fun_ty
       ; ....
       }
```

.medium-picture[![slc-ex6](image/SLC_ex2.svg)]

* Wait.. What is `unifyFun` ?

---

## Robinson's Unification Algorithm in Action

* This function does two things: .blue[type expression expansion] and .blue[unification].
* .blue[unify] means trying to make the both sides of the equation (structurally) equal.
* `unify` the symbol `tau` with the formula of `a1 -> a2`
* Collect the Constraint

$$
\tau = a1 \rightarrow a2
$$

* We allocate type variables with `newTyVarTy`

``` haskell
unifyFun :: Rho -> Tc (Rho, Rho)
unifyFun (Fun arg res) = return (arg,res)
unifyFun tau           = do { arg_ty <- newTyVarTy
                            ; res_ty <- newTyVarTy

-- recursively call unify tau (arg_ty --> res_ty) to see if it results to error.
                            ; unify tau (Fun arg_ty res_ty)

-- it is fine. tau has been substituted with arg_ty --> res_ty
                            ; return (arg_ty, res_ty) 
                            }
```

---

## Robinson's Unification Algorithm in Action

* If the argument is `Fun`, then first `unify` the argument, then `unify` its body.

``` haskell
unify :: Tau -> Tau -> Tc ()
unify (Fun arg1 res1) (Fun arg2 res2)

-- see if unify arg1 arg2 would result errors
  = do { unify arg1 arg2

-- see if unify res1 res2 would result errors
       ; unify res1 res2 
       }
```

$$
unify(a \rightarrow b = Burger \rightarrow Burger) = \\\ 
unify(a = Burger) \cup unify(b = Burger)
$$

---

## Robinson's Unification Algorithm in Action

* If one of them is meta type variable `Rho` or `Tau`

``` haskell
data MetaTv = Meta Uniq TyRef  -- Can unify with any tau-type

type TyRef = IORef (Maybe Tau)


unify (MetaTv tv1) (MetaTv tv2) | tv1 == tv2 = return ()


-- we are unifying meta type var with tau
unify (MetaTv tv) ty = unifyVar tv ty
unify ty (MetaTv tv) = unifyVar tv ty
```

``` haskell
-- we should unify where the meta type var points to with tau
unifyVar :: MetaTv -> Tau -> Tc ()
unifyVar tv1 ty2
  = do { mb_ty1 <- readTv tv1
       ; case mb_ty1 of
           Just ty1 -> unify ty1 ty2

-- this case is reserved for later hindley-milner
           Nothing  -> failTc "MetaTv is always initialized with Just here." }
```

---

## Robinson's Unification Algorithm in Action

* If it is a constant type, then check if they are matched.

``` haskell
unify (TyCon tc1) (TyCon tc2) | tc1 == tc2 
    = return ()
```

$$
unify(Burger = Burger) = \Phi \\\
$$

--

* If they are type variables, check if their .blue[names] are the same. That is .blue[a1 = a1], but .blue[a1 != a2]. It is confusing but you would see it when we add the generalization for hindley-milner.

``` haskell
unify (TyVar tv1)  (TyVar tv2)  | tv1 == tv2 
    = return ()
```
--

* Otherwise, failed to check the program.

``` haskell
unify ty1 ty2 = failTc "Unable to unify types"
```

--

* With unification algorithm, we could get back to the tree walking.

---

.medium-picture[![slc-ex3](image/SLC_ex2.svg)]

* `checkRho` checks if the `arg` has `arg_ty` or not. Recursively call `tcRho` in typechecking mode.

``` haskell
tcRho (App fun arg) exp_ty = do { fun_ty <- inferRho fun
                                ; (arg_ty, res_ty) <- unifyFun fun_ty
-- arg_ty is the expected accepted type by function definition
-- At App phase we have to check if the arg matches arg_ty
                                ; checkRho arg arg_ty
                                ; instRho res_ty exp_ty }

checkRho :: Term -> Rho -> Tc ()
checkRho expr ty = tcRho expr (Check ty)

```


---

.medium-picture[![slc-ex3](image/SLC_ex2.svg)]

* `instRho` writes the type back to the reference `res_ty`.
* We have this extra layer of abstraction is for the later extesion.

``` haskell
tcRho (App fun arg) exp_ty = do { fun_ty <- inferRho fun
                                ; (arg_ty, res_ty) <- unifyFun fun_ty
                                ; checkRho arg arg_ty

-- save the res_ty into the slot of exp_ty
-- otherwise, see if res_ty matches the expected exp_ty type
                                ; instRho res_ty exp_ty }

instRho :: Rho -> Expected Rho -> Tc ()
instRho t1 (Check t2) = unify t1 t2
instRho t1 (Infer r) = writeTcRef r t1
```


---
.medium-picture[![slc-ex3](image/SLC_ex3.svg)]

``` haskell
tcRho (App fun arg) exp_ty = do { fun_ty <- inferRho fun
                                ; (arg_ty, res_ty) <- unifyFun fun_ty
                                ; checkRho arg arg_ty
                                ; instRho res_ty exp_ty }

checkRho :: Term -> Rho -> Tc ()
checkRho expr ty = tcRho expr (Check ty)

instRho :: Rho -> Expected Rho -> Tc ()
instRho t1 (Check t2) = unify t1 t1
instRho t1 (Infer r) = writeTcRef r t1
```


---
.medium-picture[![slc-ex3](image/SLC_ex4.svg)]

``` haskell
tcRho (Ann body ann_ty) exp_ty
   = do { checkRho body ann_ty
        ; instRho ann_ty exp_ty 
        }
```

* Check if the `body` matches the `ann_ty`.

---

.medium-picture[![slc-ex4](image/SLC_ex5.svg)]

``` haskell
tcRho (Lam var body) (Infer ref)
  = do { var_ty  <- newTyVarTy
-- given symbol var inferred as var_ty, infer the body
       ; body_ty <- extendVarEnv var var_ty (inferRho body)
-- write the type back
       ; writeTcRef ref (Fun var_ty body_ty) }
```

* We allocate a type variable for lambda argument, then using `extendVarEnv` to put a record marking the argument's type is `var_ty`. This term could be looked-up during the inference of `body`.
* VarEnv = $\left\\{ x = var\\_ty_1 \right\\}$
* With the environment extended, we inference `body`, and put the inferred type `Fun var_ty body_ty` into reference.

---

.medium-picture[![slc-ex4](image/SLC_ex5.svg)]

``` haskell
tcRho (Lam var body) (Check exp_ty)
  = do { (var_ty, body_ty) <- unifyFun exp_ty
       ; extendVarEnv var var_ty (checkRho body body_ty) 
       }
```

* If we are doing type checking, we are using `unifyFun` to expand `exp_ty` into the structure of `var_ty --> body_ty`. then using `checkRho` to do typechecking.

---

.medium-picture[![slc-ex6](image/SLC_ex6.svg)]

``` haskell
tcRho (Var v) exp_ty
  = do { v_rho <- lookupVar v
       ; instRho v_rho exp_ty 
       }
```

* VarEnv = $\left\\{ x = var\\_ty_1 \right\\}$
* lookup the term `v` in the environment, and save it into `exp_ty`

---

.medium-picture[![slc-ex6](image/SLC_ex7.svg)]

``` haskell
tcRho (Lam var body) (Infer ref)
  = do { var_ty  <- newTyVarTy
       ; body_ty <- extendVarEnv var var_ty (inferRho body)
       ; writeTcRef ref (Fun var_ty body_ty) }
tcRho (Lam var body) (Check exp_ty)
  = do { (var_ty, body_ty) <- unifyFun exp_ty
       ; extendVarEnv var var_ty (checkRho body body_ty) }
```

* VarEnv = $\left\\{ x = var\\_ty_1, y = var\\_ty_2 \right\\}$

---

.medium-picture[![slc-ex6](image/SLC_ex8.svg)]

``` haskell
tcRho (Var v) exp_ty
  = do { v_rho <- lookupVar v
       ; instRho v_rho exp_ty }
```

* lookup the term `v` in the environment, and save it into `exp_ty`
* VarEnv = $\left\\{ x = var\\_ty_1, y = var\\_ty_2 \right\\}$

---

.medium-picture[![slc-ex6](image/SLC_ex9.svg)]

``` haskell
tcRho (Lit _) exp_ty
  = instRho BurgerType exp_ty
```

* Constant type case is trivial, put the constant into `exp_ty`.


---
.medium-picture[![slc-ex3](image/SLC_ex4.svg)]

``` haskell
tcRho (Ann body ann_ty) exp_ty
   = do { checkRho body ann_ty
        ; instRho ann_ty exp_ty }
```

* $body = var\\_ty_1 \rightarrow var\\_ty_2 \rightarrow Burger$.
* And we have annotation `ann_ty` as $Bread \rightarrow Beef \rightarrow Burger$

$$
unify(var\\_ty_1 \rightarrow var\\_ty_2 \rightarrow Burger = Bread \rightarrow Beef \rightarrow Burger) \\\
\Rightarrow unify(var\\_ty_1 = Bread) \cup unify(var\\_ty_2 \rightarrow Burger = Beef \rightarrow Burger) \\\
\Rightarrow unify(var\\_ty_1 = Bread) \cup unify(var\\_ty_2 = Beef) \cup \\\ 
unify(Burger = Burger) 
$$

---

.medium-picture[![slc-ex6](image/SLC_ex10.svg)]

``` haskell
tcRho (Lit _) exp_ty
  = instRho BreadType exp_ty
```

* Constant type case is trivial, put the constant into `exp_ty`.


---
.medium-picture[![slc-ex3](image/SLC_ex3.svg)]

``` haskell
tcRho (App fun arg) exp_ty = do { fun_ty <- inferRho fun
                                ; (arg_ty, res_ty) <- unifyFun fun_ty
                                ; checkRho arg arg_ty
                                ; instRho res_ty exp_ty }
```

* Check the argument `checkRho arg Bread`
* Then save `Beef -> Burger` to `exp_ty` with `instRho (Beef -> Burger) exp_ty`


---

.medium-picture[![slc-ex6](image/SLC_ex11.svg)]

``` haskell
tcRho (Lit _) exp_ty
  = instRho BeefType exp_ty
```

* Constant type case is trivial, put the constant into `exp_ty`.


---

.medium-picture[![slc-ex3](image/SLC_ex2.svg)]

``` haskell
tcRho (App fun arg) exp_ty = do { fun_ty <- inferRho fun
                                ; (arg_ty, res_ty) <- unifyFun fun_ty
                                ; checkRho arg arg_ty
                                ; instRho res_ty exp_ty }
```

* `arg_ty` is `Beef`
* `res_ty` is `Burger`
* save `Burger` into `exp_ty`

``` haskell
inferRho expr
  = do { ref <- newTcRef (error "inferRho: empty result")
       ; tcRho expr (Infer ref)
       ; readTcRef ref }
```

---

## Tree Walking

* Finally we get the whole program's type

``` haskell
inferRho :: Term -> Tc Rho
```

--
* However, this type system is too simple. No generalization.

---

## The defect of simply typed lambda calculus

* Suppose that we would like to have a generalized version of hamburger making.
* Hamburger is not only for meat, but could be prawn. And we could replace bread with rice.

![](image/jarkarta_burger.jpg)


``` haskell
( \f. Pair2 ((f bread) meat) ((f rice) prawn) ) make
```


---

## The defect of simply typed lambda calculus

* The trick discovered by Hindley and Milner independently is to add a .blue[let] into grammar
* It's called .blue[Let polymorphism].

``` haskell
let f = make in Pair2 ((f bread) meat) ((f rice) prawn)
```

* The type system is also generalized. For the language to describe "type" is added with .blue[polytype], that is `forall a. a`

* Think it like a blank label and filling it with anything you like.  .small-picture[![](image/label-it.jpg)]

``` haskell
forall a b. a -> b -> Burger
```


---

## Let Polymorphism

* Let's modify the grammar for value level expression.

``` haskell
data Term = Var Name              -- x
          | Lit BurgerType        -- burger
          | App Term Term         -- f x
          | Lam Name Term         -- \ x. x
          | Let Name Term Term    -- let x = f y in x+1
          | Ann Term Sigma        -- (f x) :: Burger
```

* We add a .blue[Let Name Term Term] here
* Polytypes are types containing variables bound by one or more for-all quantifiers, and notice that in HM system the $\forall$ is only allowed happened at the .blue[outermost].

$$
\forall a. a \rightarrow a \rightarrow a \\\
\forall a b. a \rightarrow a \rightarrow b \\\
$$

* Then we extend the structure we previously defined one by one.

---

## Let Polymorphism

* Then we extends the type expression.

$$ 
\sigma ::= \forall a. \rho \\\
\rho ::= \tau \\\
\tau ::= \tau \rightarrow \tau \, | \, ConstantType \\\
$$

* We add another meta variable .blue[Sigma] for type level expansion.
* And "BoundTv" to capture the .blue[forall] polytype.

``` haskell
type Sigma = Type
type Rho   = Type  -- No top-level ForAll
type Tau   = Type

data Type = ForAll [TyVar] Rho   -- Forall type
          | Fun    Type Type     -- Function type
          | TyCon  TyCon         -- Type constants
          | TyVar  TyVar         -- Always bound by a ForAll
          | MetaTv MetaTv        -- A meta type variable

data TyVar
  = BoundTv String               -- A type variable bound by a ForAll
  | SkolemTv String Uniq
-- Like the "a1", "a2", "a3" you see in GHC compiler message
```


---

## Instantiation

* With the polytype introduced, a corresponding concept is introduced, it's called .blue[instantiation].

--

* It's replacing .blue[type variable] captured by a .blue[forall] with a fresh solo .blue[type variable] or .blue[type constant]

--

* The LHS instantiates the RHS

$$
\forall a. a \leq Burger \\\
\forall a. a \rightarrow a \leq Burger \rightarrow Burger \\\
\forall a. a \rightarrow a \leq b_1 \rightarrow b_1 \\\
\forall a. a \rightarrow a \leq c_1 \rightarrow c_1 \\\
$$

You could instantiate a blank label .small-picture[![](image/label-it.jpg)] to .tiny-picture[![](image/burger-king.png)]

---

## Instantiation

* Substitute the type variable appears in the topmost `forall`, with newly instantiated type variables, they have unique names different from others.

``` haskell
instantiate :: Sigma -> Tc Rho
instantiate (ForAll tvs ty) = do { tvs' <- mapM (\_ -> newMetaTyVar) tvs
                                 ; return (substTy tvs (map MetaTv tvs') ty) }
instantiate ty = return ty
```

$$
\forall a_1 a_2. a_1 \rightarrow a_2  \Rightarrow  \tau_1 \rightarrow \tau_2
$$

* Then

``` haskell
instRho :: Rho -> Expected Rho -> Tc ()
instRho t1 (Check t2) = unify t1 t1
instRho t1 (Infer r) = writeTcRef r t1
```

Becomes

``` haskell
instSigma :: Sigma -> Expected Rho -> Tc ()
instSigma t1 (Check t2) = unify t1 t2
instSigma t1 (Infer r)  = do { t1' <- instantiate t1
                             ; writeTcRef r t1' }
```


---

## Generalization

* Another concept introduced is called .blue[generalization].
* It's replacing a .blue[type variable] with a .blue[polytype]. Think it like replacing a simple function in C++ and generalize it with a C++ template function.

``` haskell
inferRho expr
  = do { ref <- newTcRef (error "inferRho: empty result")
       ; tcRho expr (Infer ref)
       ; readTcRef ref }
```

Becomes

``` haskell
inferSigma :: Term -> Tc Sigma
inferSigma e
   = do { exp_ty <- inferRho e
        ; env_tys <- getEnvTypes
        ; env_tvs <- getMetaTyVars env_tys
        ; res_tvs <- getMetaTyVars [exp_ty]
-- excluding the symbols that have been bound in outer scope
        ; let forall_tvs = res_tvs \\ env_tvs
        ; quantify forall_tvs exp_ty }
```

* First using `inferRho` to infer the type of the term, getting `exp_ty`, in `exp_ty` it contains some unbound type variables.
* We use `quantify` to add `forall` for those unbound type variables.


---

## Generalization

``` haskell
inferSigma :: Term -> Tc Sigma
inferSigma e
   = do { exp_ty <- inferRho e
        ; env_tys <- getEnvTypes
        ; env_tvs <- getMetaTyVars env_tys
        ; res_tvs <- getMetaTyVars [exp_ty]
-- excluding the symbols that have been bound in outer scope
        ; let forall_tvs = res_tvs \\ env_tvs
        ; quantify forall_tvs exp_ty }
```

* With knowing that $a_1$ is bound by outer scopes, so we skip it. And since we would like to generalize $b_1$. We add a $\forall$ to close over $b$.

$$
b_1 \rightarrow a_1
$$

Becomes

$$
\forall b. b \rightarrow a_1
$$

Wipe out .tiny-picture[![](image/burger-king.png)] to be blank label .tiny-picture[![](image/label-it.jpg)] 

---

## Generalization

* It is tricky when it comes to comparing polytypes. That somehow complicates the generalization from `checkRho` to `checkSigma`.

* Say the RHS is the annotated type, and the left hand side is the inferred type. $\leq$ means "more polymorphic".

$$
\forall a b. a \rightarrow b \leq \forall c. c \rightarrow c
$$

* A trick is to replace $\forall$ to type variable with previosly unseen name, and use the vanilla `checkRho` to see if it is unifiable.

$$
\forall a b. a \rightarrow b \leq c_1 \rightarrow c_1
$$

* Also we have to check if any of the type variables replaced escape to the outer scope.


---

## Generalization

``` haskell
checkRho :: Term -> Rho -> Tc ()
checkRho expr ty = tcRho expr (Check ty)
```

Becomes

``` haskell
checkSigma :: Term -> Sigma -> Tc ()
checkSigma expr sigma

= do { (skol_tvs, rho) <- skolemise sigma

-- now rho is ordinary case we demonstrated before
     ; checkRho expr rho

-- the rest is for occursCheck
-- making sure no free var escape
     ; env_tys <- getEnvTypes
     ; esc_tvs <- getFreeTyVars (sigma : env_tys)
     ; let bad_tvs = filter (`elem` esc_tvs) skol_tvs
     ; assert (null bad_tvs) "Type not polymorphic enough" }

-- replace type var bound by forall with a newly created unique type var
skolemise :: Sigma -> Tc ([TyVar], Rho)
skolemise (ForAll tvs ty)
  = do { sks1 <- mapM newSkolemTyVar tvs
       ; ty' <- substTy tvs (map TyVar sks1) ty
       ; return (sks1, ty') }
```

---

.medium-picture[![slc-ex6](image/let_ex1.svg)]

``` haskell
let f = \x. \y. burger in ((f bread) meat)
```

---

.medium-picture[![slc-ex6](image/let_ex2.svg)]

* When bumping into a `Let`, we use `inferSigma` but not `inferRho`. `inferSigma` will generalize the type expression with a toplevel `forall` in `var_ty`. So that the `forall` variables could be freely instantiated duing the inference of the `body`.

``` haskell
tcRho (Let var rhs body) exp_ty
  = do { var_ty <- inferSigma rhs
       ; extendVarEnv var var_ty (tcRho body exp_ty) }
```

* VarEnv = $\left\\{ f = \forall a b. a \rightarrow b \rightarrow Burger \right\\}$

---

.medium-picture[![slc-ex6](image/let_ex3.svg)]

* When bumping into a `App`, we no longer use `checkRho` or `instRho`. The polytype version .blue[`checkSigma`] and .blue[`instSigma`] would typecheck the argument see if the input argument type could subsume the function argument type. And `instSigma` would instantiate the function return type to the expected type of `App`

``` haskell
tcRho (App fun arg) exp_ty
  = do { fun_ty <- inferRho fun
       ; (arg_ty, res_ty) <- unifyFun fun_ty
       ; checkSigma arg arg_ty
       ; instSigma res_ty exp_ty }
```


---

.medium-picture[![slc-ex6](image/let_ex4.svg)]

``` haskell
tcRho (App fun arg) exp_ty
  = do { fun_ty <- inferRho fun
       ; (arg_ty, res_ty) <- unifyFun fun_ty
       ; checkSigma arg arg_ty
       ; instSigma res_ty exp_ty }
```

---

.medium-picture[![slc-ex6](image/let_ex5.svg)]

* for `Var` case, the instantiation also has to be applied.

``` haskell
tcRho (Var v) exp_ty
  = do { v_sigma <- lookupVar v
       ; instSigma v_sigma exp_ty }
```

* VarEnv = $\left\\{ f = \forall a b. a \rightarrow b \rightarrow Burger \right\\}$

---

.medium-picture[![slc-ex6](image/let_ex6.svg)]

* For contant case, it is also no longer a simple saving, but has to instantiate the constant type.

``` haskell
tcRho (Lit _) exp_ty
  = instSigma BreadType exp_ty
```


* For annotation, we would check if the marked annotation could subsume the type of the `body`, if it does, then using annotation type to instantiate expected type.

``` haskell
tcRho (Ann body ann_ty) exp_ty
   = do { checkSigma body ann_ty
        ; instSigma ann_ty exp_ty }
```


---

## Change in Unification

* For `unifyVar`, now it is possible to be unbound. Since the `MetaVar` could be initialized by `instantiate` with `Nothing`. We add `unifyUnboundVar` to handle this case.

``` haskell
unifyVar :: MetaTv -> Tau -> Tc ()
unifyVar tv1 ty2
  = do { mb_ty1 <- readTv tv1
       ; case mb_ty1 of
           Just ty1 -> unify ty1 ty2
-- The case we reserved before now has to be considered.
           Nothing  -> unifyUnboundVar tv1 ty2 }
```


``` haskell
instantiate (ForAll tvs ty) = do { tvs' <- mapM (\_ -> newMetaTyVar) tvs
                                 ; return (substTy tvs (map MetaTv tvs') ty) }

newMetaTyVar ∷ Tc MetaTv
newMetaTyVar = do { uniq ← newUnique
                  ; tref ← newTcRef Nothing
                  ; return (Meta uniq tref) }
```

---

## Change in Unification


``` haskell
unifyUnboundVar :: MetaTv -> Tau -> Tc ()
unifyUnboundVar tv1 ty2@(MetaTv tv2)  
-- tv1 is the MetaTv created in instantiate
  = do { mb_ty2 <- readTv tv2
       ; case mb_ty2 of
-- check the case unify (MetaTv tv1) (MetaTv tv2) | tv1 == tv2 = return ()
           Just ty2' -> unify (MetaTv tv1) ty2'
-- Then bind meta tv1 to ty2, so that tv1 has the same structure as ty2
           Nothing  -> writeTv tv1 ty2 }
```

``` haskell
unifyUnboundVar tv1 ty2  -- ty2 is Fun or TyVar or TyCon
  = do { tvs2 <- getMetaTyVars [ty2]
--see if accidentally capture the vars
       ; if tv1 `elem` tvs2 then
            occursCheckErr tv1 ty2
         else

-- bind meta tv1 to ty2, so that tv1 has the same structure as ty2
            writeTv tv1 ty2 }
```


---

## What's the defect of hindley-milner type system?

* Even with the addition of .blue[let], it only tells the system to "generalize" at the syntax where "let" happened.

```haskell
(\f. Pair2 (f "foo") (f 13)) (\x. x)
```

* Consider the following use case. We want to have the `make` be passed in `makeBurgers` function

```haskell
make :: forall a b. a -> b -> Burger

makeBurgers :: (forall a b. a -> b -> Burger) -> (Burger, Burger)
makeBurgers g = let f x = Pair2 ((x bread) beef) ((x rice) prawn)
                in f g

h = makeBurgers make
```

* It would not typecheck by hindley-milner, since the `makeBurgers`'s forall is not at the top level.


---

## Higher-rank type system

* To solve the problem of let polymorphism where it is not generalized at the .blue[argument].

* Allowing the argument to be annotated at the argument. That would help the type system to infer, meanwhile not requireing a big change in hindley-milner type system.

```
let g = \(f1 :: forall a. a -> a). Pair2 (f1 1) (f1 True)
in let f = \x. x
in g f
```

* Adding a little burden to programmers, but without greatly overhaul the whole system.

---

## Change in Value and Type Expression

* Add type annotation in the abstraction rule, i.e. ALam

``` haskell
data Term = Var Name              -- x
          | Lit BurgerType        -- burger
          | App Term Term         -- f x
          | Lam Name Term         -- \x. x
          | ALam Name Sigma Term  -- \x :: Burger . x
          | Let Name Term Term    -- let x = f y in x+1
          | Ann Term Sigma        -- (f x) :: Burger
```

* Make $\rho$ could derive $\sigma \rightarrow \sigma$

$$
\sigma ::= \forall a. \rho \\\
\rho ::= \tau \, | \, \sigma \rightarrow \sigma^{\prime} \\\
\tau::= \tau \rightarrow \tau \, | \, ConstantType \\\
$$

* Therefore it is possible to have $\forall$ not at the top level now

$$
Bool \rightarrow (\forall a . a \rightarrow a) \\\
(\forall b. b \rightarrow b) \rightarrow Bool \\\
$$


---

## What is the most difficult in extending to higher-rank

* It is comparing two polytypes. Since we allow $\forall$ to be put at anywhere. Apart from that, it is astonishingly few changes required.

* Are the following two equivalent?

$$
\forall ab. a \rightarrow b \rightarrow b \\\
\forall a. a \rightarrow (\forall b.b \rightarrow b) \\\
$$

* .blue[No] if you derive it with intuition. The second could be rewritten to the first one, but the first one could not be rewritten to the second.

$$
\forall a. a \rightarrow (\forall b.b \rightarrow b) \\\
\Rightarrow \forall a. a. \rightarrow b_1 \rightarrow b_1 \\\
\Rightarrow \forall a c. a \rightarrow c \rightarrow c \\\
\Rightarrow \forall a b. a \rightarrow b \rightarrow b \\\
$$

* And this is an .blue[issue], since the type inferred by system could be the first, but the programmer annotate the type to be the second.


---

## Subsumption

* However, we would like this case to be isomorphic. It is the following should be typechecked.

```
let f = \x. \y. y in (f :: forall a. a -> (forall b. b -> b))
```


* That is, the following should hold.

$$
\forall a. a \rightarrow (\forall b.b \rightarrow b) \leq \forall ab. a \rightarrow b \rightarrow b \\\
\forall a. a \rightarrow (\forall b.b \rightarrow b) \geq \forall ab. a \rightarrow b \rightarrow b \\\
$$



---

## Subsumption

* We define the prenex form: With all of the .blue[forall] at the .blue[head] of the type annotation.

* And the prenex conversion is like the following, floating the .blue[forall] at the right of the arrows to the top.

$$
\forall a. a \rightarrow (\forall b.b \rightarrow b)
$$

to 

$$
\forall ab. a \rightarrow b \rightarrow b
$$


--
* The technique is to convert the annotated type expression into prenex form and see if one is more generalized than the other.

---

## Deep Skolemization

* We combine this floating out process and replacing `forall` var with simple type var into a recursive function.

* It's called .blue[Deep skolemization].

``` haskell
skolemise :: Sigma -> Tc ([TyVar], Rho)
skolemise (ForAll tvs ty)
  = do { sks1 <- mapM newSkolemTyVar tvs
       ; (sks2, ty') <- skolemise (substTy tvs (map TyVar sks1) ty)
       ; return (sks1 ++ sks2, ty') }
skolemise (Fun arg_ty res_ty)
  = do { (sks, res_ty') <- skolemise res_ty
       ; return (sks, Fun arg_ty res_ty') }
skolemise ty = return ([], ty)
```

* Floating out.

$$
\forall a. a \rightarrow (\forall b.b \rightarrow b) \\\
\forall ab. a \rightarrow b \rightarrow b
$$


---

## Subsumption

* `subsCheck` compare two polytypes (two `Sigma`)

* The trick is that we skolemize one of it, and see if the other polytype could instantiate the `Rho` part.

``` haskell
subsCheck :: Sigma -> Sigma -> Tc ()
subsCheck sigma1 sigma2 
  = do { (skol_tvs, rho2) <- skolemise sigma2
       ; subsCheckRho sigma1 rho2
-- making sure no accidentally captured free vars.
       ; esc_tvs <- getFreeTyVars [sigma1, sigma2]
       ; let bad_tvs = filter (`elem` esc_tvs) skol_tvs
       ; assert (null bad_tvs) (failTc "Subsumption failed")
```

* For example, the annotation `sigma2` is $\forall a. a \rightarrow \forall b. b$ and inferred type is $\forall a b. a \rightarrow b$

* Then `skol_tvs` is `[a, b]` and `rho2` is $a \rightarrow b$

* We see $\forall a b. a \rightarrow b$ could instantiate $a \rightarrow b$

---

## Subsumption

* `rho2` is in prenex form

``` haskell
subsCheckRho :: Sigma -> Rho -> Tc ()
-- capture all of the ForAll form sigma
subsCheckRho sigma1@(ForAll _ _) rho2
  = do { rho1 <- instantiate sigma1
       ; subsCheckRho rho1 rho2 }
-- from now on the Sigma is actually rho for potential further expansion
subsCheckRho rho1 (Fun a2 r2)
  = do { (a1,r1) <- unifyFun rho1
       ; subsCheckFun a1 r1 a2 r2 }
subsCheckRho (Fun a1 r1) rho2
  = do { (a2,r2) <- unifyFun rho2
       ; subsCheckFun a1 r1 a2 r2 }
-- two tau types without forall, using unify to check it
subsCheckRho tau1 tau2
  = unify tau1 tau2


subsCheckFun :: Sigma -> Rho -> Sigma -> Rho -> Tc ()
                        -- using sigma version for argument
subsCheckFun a1 r1 a2 r2 = do { subusCheck a2 a1
                        -- using rho version for body
                              ; subsCheckRho r1 r2
                              }
```



---

## All the change needed for Inference

* With subsumption rule added, the argument annotation unification could be handled.

* For inference, it is intuitive. Extend the environment by marking `var` with `var_ty`, which is the annotated type, then do the inference for `body`

* For type checking, we just apply `subsCheck` for .blue[argument], and do the normal check for body.

``` haskell
tcRho (ALam var var_ty body) (Check exp_ty)
  = do { (arg_ty, body_ty) <- unifyFun exp_ty
       ; subsCheck arg_ty var_ty
       ; extendVarEnv var var_ty (checkRho body body_ty) }

tcRho (ALam var var_ty body) (Infer ref)
  = do { body_ty <- extendVarEnv var var_ty (inferRho body)
       ; writeTcRef ref (Fun var_ty body_ty) }
```

---

## Wrapping up

* The hindley milner system is the foundation of Haskell98 standrad. With the knowledge about it, we could understand its extensions and new models inspired by HM.

* Higher rank corresponds to GHC's extension .blue[-XRankNTypes], with this addon, we could make the use case like passing in callback function to be typeable.

* This slide tries to reduce the usage of mathematical logical deduction for better comprehension. But to understand other papers, you still have to pickup the intuition of mathematical logic.

---

class: center, middle, large

Thank you

### Code is [here](https://github.com/MnO2/hindley-milner)


    </textarea>
    <script>
        var is_local = (window.location.hostname == "localhost");

        function add_script(src, callback) {
            var s = document.createElement("script");
            s.setAttribute("src", src);
            s.onload = callback;
            document.body.appendChild(s);
        }

        function load_slides() {
            var query = window.location.search.substring(1);
            var slideshow = remark.create();

            // Setup MathJax
            MathJax.Hub.Config({
                tex2jax: {
                    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    processescapes: true,
                },
                jax: ["input/TeX","output/HTML-CSS"],
                displayAlign: "left",
                displayIndent: "2em"
            });


            MathJax.Hub.Configured();
        }

        if (is_local) {
            add_script("javascript/remark-latest.min.js", function() {
                add_script("javascript/MathJax.js", load_slides);
            });
        } else {
            add_script("https://gnab.github.io/remark/downloads/remark-latest.min.js", function() {
                add_script("http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured", load_slides);
            });
        }
    </script>
  </body>
</html>
